#!/bin/bash
# Repository management script for crossplay
# Allows adding, removing, listing, and updating sibling repositories

set -e

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_ROOT="$(cd "$SCRIPT_DIR/.." && pwd)"

CONFIG_FILE="$PROJECT_ROOT/config/crossplay.config.yaml"
ENV_FILE="$PROJECT_ROOT/.env"

# Ensure config directory exists
mkdir -p "$PROJECT_ROOT/config"

# Function to show usage
usage() {
    echo "Usage: $0 {add|remove|list|update} [type] [path]"
    echo ""
    echo "Commands:"
    echo "  add <type> <path>    - Add/connect a repository"
    echo "  remove <type>        - Remove a repository"
    echo "  list                 - List all repositories"
    echo "  update <type> <path> - Update repository path"
    echo ""
    echo "Types: video, ros2, nlp, or custom"
    exit 1
}

# Function to backup config
backup_config() {
    if [ -f "$CONFIG_FILE" ]; then
        cp "$CONFIG_FILE" "$CONFIG_FILE.bak"
    fi
    if [ -f "$ENV_FILE" ]; then
        cp "$ENV_FILE" "$ENV_FILE.bak"
    fi
}

# Function to restore config on error
restore_config() {
    if [ -f "$CONFIG_FILE.bak" ]; then
        mv "$CONFIG_FILE.bak" "$CONFIG_FILE"
    fi
    if [ -f "$ENV_FILE.bak" ]; then
        mv "$ENV_FILE.bak" "$ENV_FILE"
    fi
}

# Function to validate repo path
validate_path() {
    local path="$1"
    local abs_path
    
    # Convert to absolute path
    if [[ "$path" = /* ]]; then
        abs_path="$path"
    else
        abs_path=$(cd "$PROJECT_ROOT" && cd "$path" 2>/dev/null && pwd || echo "")
    fi
    
    if [ -z "$abs_path" ] || [ ! -d "$abs_path" ]; then
        echo "ERROR: Repository path does not exist: $path"
        return 1
    fi
    
    echo "$abs_path"
    return 0
}

# Function to check if container is running
is_container_running() {
    local service="$1"
    docker ps --format '{{.Names}}' | grep -q "^crossplay_${service}$" 2>/dev/null || return 1
}

# Function to add repository
add_repo() {
    local type="$1"
    local path="$2"
    
    if [ -z "$type" ] || [ -z "$path" ]; then
        echo "ERROR: Type and path are required"
        usage
    fi
    
    # Validate path
    local abs_path
    abs_path=$(validate_path "$path") || exit 1
    
    echo "Adding repository: $type -> $abs_path"
    
    # Backup config
    backup_config
    
    # Create config if it doesn't exist
    if [ ! -f "$CONFIG_FILE" ]; then
        cat > "$CONFIG_FILE" << EOF
# Crossplay Configuration
# Generated by manage-repos script

repositories:
EOF
    fi
    
    # Check if repo already exists
    if grep -q "^  ${type}:" "$CONFIG_FILE" 2>/dev/null; then
        echo "WARNING: Repository $type already exists. Use 'update' command to change path."
        restore_config
        exit 1
    fi
    
    # Add to config
    cat >> "$CONFIG_FILE" << EOF
  ${type}:
    enabled: true
    path: ${abs_path}
    type: ${type}
EOF
    
    # Update .env file
    if [ -f "$ENV_FILE" ]; then
        # Convert type to env var name (uppercase with _PATH suffix)
        local env_var="${type^^}_PATH"
        # Replace or add the variable
        if grep -q "^${env_var}=" "$ENV_FILE"; then
            sed -i.bak "s|^${env_var}=.*|${env_var}=${abs_path}|" "$ENV_FILE"
            rm -f "$ENV_FILE.bak"
        else
            echo "${env_var}=${abs_path}" >> "$ENV_FILE"
        fi
    fi
    
    # Stop container if running
    if is_container_running "$type"; then
        echo "Stopping existing container for $type..."
        docker stop "crossplay_${type}" 2>/dev/null || true
    fi
    
    echo "✓ Repository $type added successfully"
    echo "  Path: $abs_path"
    echo ""
    echo "Run ./scripts/launch.sh to start services with the new repository"
}

# Function to remove repository
remove_repo() {
    local type="$1"
    
    if [ -z "$type" ]; then
        echo "ERROR: Type is required"
        usage
    fi
    
    if [ ! -f "$CONFIG_FILE" ]; then
        echo "ERROR: Configuration file not found"
        exit 1
    fi
    
    # Check if repo exists
    if ! grep -q "^  ${type}:" "$CONFIG_FILE" 2>/dev/null; then
        echo "ERROR: Repository $type not found"
        exit 1
    fi
    
    echo "Removing repository: $type"
    
    # Stop container if running
    if is_container_running "$type"; then
        echo "Stopping container for $type..."
        docker stop "crossplay_${type}" 2>/dev/null || true
        docker rm "crossplay_${type}" 2>/dev/null || true
    fi
    
    # Backup config
    backup_config
    
    # Remove from config (simple sed approach)
    # Create temp file without the repo section
    awk -v type="$type" '
        /^  [a-z]+:/ { in_section = ($0 ~ "^  " type ":") }
        !in_section { print }
        in_section && /^  [a-z]+:/ && !/^  " type ":/ { in_section = 0; print }
    ' "$CONFIG_FILE" > "$CONFIG_FILE.tmp" && mv "$CONFIG_FILE.tmp" "$CONFIG_FILE"
    
    # Update .env file
    if [ -f "$ENV_FILE" ]; then
        local env_var="${type^^}_PATH"
        sed -i.bak "/^${env_var}=/d" "$ENV_FILE"
        rm -f "$ENV_FILE.bak"
    fi
    
    echo "✓ Repository $type removed successfully"
}

# Function to list repositories
list_repos() {
    if [ ! -f "$CONFIG_FILE" ]; then
        echo "No repositories configured"
        echo "Run './scripts/setup.sh' or './scripts/manage-repos.sh add <type> <path>' to add repositories"
        exit 0
    fi
    
    echo "=== Configured Repositories ==="
    echo ""
    
    # Parse and display repos
    while IFS= read -r line; do
        if [[ "$line" =~ ^\ *([a-z]+): ]]; then
            type="${BASH_REMATCH[1]}"
            enabled=""
            path=""
            
            # Read next few lines to get enabled and path
            while IFS= read -r next_line; do
                if [[ "$next_line" =~ enabled:\ *(true|false) ]]; then
                    enabled="${BASH_REMATCH[1]}"
                elif [[ "$next_line" =~ path:\ *(.*) ]]; then
                    path="${BASH_REMATCH[1]}"
                elif [[ "$next_line" =~ ^\ *[a-z]+: ]]; then
                    break
                fi
            done
            
            # Check container status
            status="stopped"
            if is_container_running "$type"; then
                status="running"
            fi
            
            echo "Type: $type"
            echo "  Enabled: $enabled"
            echo "  Path: $path"
            echo "  Container: $status"
            echo ""
        fi
    done < "$CONFIG_FILE"
}

# Function to update repository
update_repo() {
    local type="$1"
    local path="$2"
    
    if [ -z "$type" ] || [ -z "$path" ]; then
        echo "ERROR: Type and path are required"
        usage
    fi
    
    if [ ! -f "$CONFIG_FILE" ]; then
        echo "ERROR: Configuration file not found"
        exit 1
    fi
    
    # Check if repo exists
    if ! grep -q "^  ${type}:" "$CONFIG_FILE" 2>/dev/null; then
        echo "ERROR: Repository $type not found. Use 'add' command to add it."
        exit 1
    fi
    
    # Validate path
    local abs_path
    abs_path=$(validate_path "$path") || exit 1
    
    echo "Updating repository: $type -> $abs_path"
    
    # Backup config
    backup_config
    
    # Update path in config (simple sed approach)
    sed -i.bak "/^  ${type}:/,/^  [a-z]*:/ s|path:.*|path: ${abs_path}|" "$CONFIG_FILE"
    rm -f "$CONFIG_FILE.bak"
    
    # Update .env file
    if [ -f "$ENV_FILE" ]; then
        local env_var="${type^^}_PATH"
        if grep -q "^${env_var}=" "$ENV_FILE"; then
            sed -i.bak "s|^${env_var}=.*|${env_var}=${abs_path}|" "$ENV_FILE"
            rm -f "$ENV_FILE.bak"
        fi
    fi
    
    # Restart container if running
    if is_container_running "$type"; then
        echo "Restarting container for $type..."
        docker restart "crossplay_${type}" 2>/dev/null || true
    fi
    
    echo "✓ Repository $type updated successfully"
    echo "  New path: $abs_path"
}

# Main command handling
case "${1:-}" in
    add)
        add_repo "$2" "$3"
        ;;
    remove)
        remove_repo "$2"
        ;;
    list)
        list_repos
        ;;
    update)
        update_repo "$2" "$3"
        ;;
    *)
        usage
        ;;
esac

